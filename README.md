# Разработка серверной части приложений PostgreSQL 12. Базовый курс.

## Docker-compose script

### Запуск

```bash
docker compose -f "docker-compose.yml" up -d --build
```

### Остановка

```bash
docker compose -f "docker-compose.yml" down
```

### Подключиться к контейнеру postgres

```bash
docker exec -it postgres-dev1-postgres-1 /bin/bash
```

### Запуск psql

[Локальная установка psql](./psql-setup.md)

```bash
# Локально:
psql -h localhost -U postgres

# В контейнере:
psql -U postgres
```

## Практика

### 1. Базовый инструментарий

#### 1.1. Параметры конфигурации

Установите в postgresql.conf для параметра work_mem значение 8 Мбайт.

Обновите конфигурацию и проверьте, что изменения вступили в силу.

#### 1.2. Выполнение скриптов в psql

Запишите в файл ddl.sql команду CREATE TABLE на создание любой таблицы.

Запишите в файл populate.sql команды на вставку строк в эту таблицу.

Войдите в psql, выполните оба скрипта и проверьте, что таблица создалась и в ней появились записи.

#### 1.3. Просмотр журнала

Найдите в журнале сервера строки за сегодняшний день.

[Посмотреть ответы](./src/dev1_01_tools_overview/answers.md)

### 2. Общее устройство PostgreSQL

### 3. Изоляция и многоверсионность

#### 3.1. Уровень изоляции Read Committed

Создайте таблицу с одной строкой.

Начните первую транзакцию на уровне изоляции Read Committed и выполните запрос к таблице.

Во втором сеансе удалите строку и зафиксируйте изменения.

Сколько строк увидит первая транзакция, выполнив тот же запрос повторно? Проверьте.

Завершите первую транзакцию.

#### 3.2. Уровень изоляции Repeatable Read

Повторите все то же самое, но пусть теперь транзакция работает на уровне изоляции Repeatable Read: BEGIN ISOLATION LEVEL
REPEATABLE READ;

Объясните отличия.

[Посмотреть ответы](./src/dev1_03_arch_mvcc_overview/answers.md)

### 4. Буферный кеш и журнал

#### 4.1. Использование кеша для обычных и временных таблиц

Проверьте, как используется буферный кеш в случае обновления одной строки в обычной и во временной таблице.

Попробуйте объяснить отличие.

#### 4.2. Нежурналируемые таблицы при сбое

Создайте нежурналируемую таблицу и вставьте в нее несколько строк.

Сымитируйте сбой системы, остановив сервер в режиме immediate, как в демонстрации.

Запустите сервер и проверьте, что произошло с таблицей.

Найдите в журнале сообщений сервера упоминание о восстановлении после сбоя.

[Посмотреть ответы](./src/dev1_04_arch_wal_overview/answers.md)

### 5. Логическая структура

#### 5.1. Новые схемы

В новой базе данных создайте схему, названную так же, как и пользователь.

Создайте схему app.

Создайте несколько таблиц в обеих схемах.

#### 5.2. Список схем

Получите в psql описание созданных схем и список всех таблиц в них.

#### 5.3. Поиск по схемам

Установите путь поиска так, чтобы при подключении к базе данных таблицы из обеих схем были доступны по
неквалифицированному имени; приоритет должна иметь «пользовательская» схема.

Проверьте правильность настройки.

[Посмотреть ответы](./src/dev1_05_data_logical/answers.md)

### 6. Физическая структура

#### 6.1. Табличные пространства и таблица

Создайте новую базу данных и подключитесь к ней.

Создайте табличное пространство ts.

Создайте таблицу t в табличном пространстве ts и добавьте в нее несколько строк.

#### 6.2. Размер данных

Вычислите объем, занимаемый базой данных, таблицейи табличными пространствами ts и pg_default.

#### 6.3. Перенос таблицы

Перенесите таблицу в табличное пространство pg_default.

Как изменился объем табличных пространств?

#### 6.4. Удаление табличного пространства

Удалите табличное пространство ts.

[Посмотреть ответы](./src/dev1_06_data_physical/answers.md)

### 7. Приложение «Книжный магазин». Схема данных и интерфейс

#### 1.

#### 2.

#### 3.

[dev1_07_bstore_schema](src%2Fdev1_07_bstore_schema)

### 8. Функции

#### 1.

#### 2.

#### 3.

[dev1_08_sql_func](src%2Fdev1_08_sql_func)

### 9. Процедуры

#### 1.

#### 2.

#### 3.

[dev1_09_sql_proc](src%2Fdev1_09_sql_proc)

### 10. Составные типы

#### 1.

#### 2.

#### 3.

[dev1_10_sql_row](src%2Fdev1_10_sql_row)

### 11. Обзор и конструкции языка

#### 1.

#### 2.

#### 3.

[dev1_11_plpgsql_introduction](src%2Fdev1_11_plpgsql_introduction)

### 12. Выполнение запросов

#### 1.

#### 2.

#### 3.

[dev1_12_plpgsql_queries](src%2Fdev1_12_plpgsql_queries)

### 13. Курсоры

#### 1.

#### 2.

#### 3.

[dev1_13_plpgsql_cursors](src%2Fdev1_13_plpgsql_cursors)

### 14. Динамические команды

#### 1.

#### 2.

#### 3.

[dev1_14_plpgsql_dynamic](src%2Fdev1_14_plpgsql_dynamic)

### 15. Массивы

#### 1.

#### 2.

#### 3.

[dev1_15_plpgsql_arrays](src%2Fdev1_15_plpgsql_arrays)

### 16. Обработка ошибок

#### 1.

#### 2.

#### 3.

[dev1_16_plpgsql_exceptions](src%2Fdev1_16_plpgsql_exceptions)

### 17. Триггеры

#### 1.

#### 2.

#### 3.

[dev1_17_plpgsql_triggers](src%2Fdev1_17_plpgsql_triggers)

### 18. Отладка

#### 1.

#### 2.

#### 3.

[dev1_18_plpgsql_debug](src%2Fdev1_18_plpgsql_debug)

### 19. Обзор разграничения доступа

#### 1.

#### 2.

#### 3.

[dev1_19_access_overview](src%2Fdev1_19_access_overview)

### 20. Логическое резервирование

#### 1.

#### 2.

#### 3.

[dev1_20_backup_logical](src%2Fdev1_20_backup_logical)